#include <avr/io.h>
#define F_CPU 8000000UL		/* Define CPU Frequency e.g. here its 8MHz */

#include <avr/interrupt.h>
//#include <bit.h>
//#include <timer.h>
#include <stdio.h>
#include <util/delay.h>

#include "nokia5110.h"


#define D4 ((~PIND >> 4) & 0x01)
#define D6 ((~PIND >> 6) & 0x01)


volatile unsigned char TimerFlag = 0; // TimerISR() sets this to 1. C programmer should clear to 0.

// Internal variables for mapping AVR's ISR to our cleaner TimerISR model.
unsigned long _avr_timer_M = 1; // Start count from here, down to 0. Default 1ms
unsigned long _avr_timer_cntcurr = 0; // Current internal count of 1ms ticks

// Set TimerISR() to tick every M ms
void TimerSet(unsigned long M) {
	_avr_timer_M = M;
	_avr_timer_cntcurr = _avr_timer_M;
}

void TimerOn() {
	// AVR timer/counter controller register TCCR1
	TCCR1B 	= 0x0B;	// bit3 = 1: CTC mode (clear timer on compare)
	// bit2bit1bit0=011: prescaler /64
	// 00001011: 0x0B
	// SO, 8 MHz clock or 8,000,000 /64 = 125,000 ticks/s
	// Thus, TCNT1 register will count at 125,000 ticks/s

	// AVR output compare register OCR1A.
	OCR1A 	= 125;	// Timer interrupt will be generated when TCNT1==OCR1A
	// We want a 1 ms tick. 0.001 s * 125,000 ticks/s = 125
	// So when TCNT1 register equals 125,
	// 1 ms has passed. Thus, we compare to 125.
	// AVR timer interrupt mask register

	TIMSK1 	= 0x02; // bit1: OCIE1A -- enables compare match interrupt

	//Initialize avr counter
	TCNT1 = 0;

	// TimerISR will be called every _avr_timer_cntcurr milliseconds
	_avr_timer_cntcurr = _avr_timer_M;

	//Enable global interrupts
	SREG |= 0x80;	// 0x80: 1000000
}

void TimerOff() {
	TCCR1B 	= 0x00; // bit3bit2bit1bit0=0000: timer off
}

void TimerISR() {
	TimerFlag = 1;
}

// In our approach, the C programmer does not touch this ISR, but rather TimerISR()
ISR(TIMER1_COMPA_vect)
{
	// CPU automatically calls when TCNT0 == OCR0 (every 1 ms per TimerOn settings)
	_avr_timer_cntcurr--; 			// Count down to 0 rather than up to TOP
	if (_avr_timer_cntcurr == 0) { 	// results in a more efficient compare
		TimerISR(); 				// Call the ISR that the user uses
		_avr_timer_cntcurr = _avr_timer_M;
	}
}

// 0.954 hz is lowest frequency possible with this function,
// based on settings in PWM_on()
// Passing in 0 as the frequency will stop the speaker from generating sound
void set_PWM(double frequency) {
	static double current_frequency; // Keeps track of the currently set frequency
	// Will only update the registers when the frequency changes, otherwise allows
	// music to play uninterrupted.
	if (frequency != current_frequency) {
		if (!frequency) { TCCR3B &= 0x08; } //stops timer/counter
		else { TCCR3B |= 0x03; } // resumes/continues timer/counter
		
		// prevents OCR3A from overflowing, using prescaler 64
		// 0.954 is smallest frequency that will not result in overflow
		if (frequency < 0.954) { OCR3A = 0xFFFF; }
		
		// prevents OCR3A from underflowing, using prescaler 64					// 31250 is largest frequency that will not result in underflow
		else if (frequency > 31250) { OCR3A = 0x0000; }
		
		// set OCR3A based on desired frequency
		else { OCR3A = (short)(8000000 / (128 * frequency)) - 1; }

		TCNT3 = 0; // resets counter
		current_frequency = frequency; // Updates the current frequency
	}
}

void PWM_on() {
	TCCR3A = (1 << COM3A0);
	// COM3A0: Toggle PB6 on compare match between counter and OCR3A
	TCCR3B = (1 << WGM32) | (1 << CS31) | (1 << CS30);
	// WGM32: When counter (TCNT3) matches OCR3A, reset counter
	// CS31 & CS30: Set a prescaler of 64
	set_PWM(0);
}

void PWM_off() {
	TCCR3A = 0x00;
	TCCR3B = 0x00;
}


//--------Find GCD function --------------------------------------------------
unsigned long int findGCD(unsigned long int a, unsigned long int b)
{
	unsigned long int c;
	while(1){
		c = a%b;
		if(c==0){return b;}
		a = b;
b = c;
	}
	return 0;
}
//--------End find GCD function ----------------------------------------------

//--------Task scheduler data structure---------------------------------------
// Struct for Tasks represent a running process in our simple real-time operating system.
typedef struct _task {
	/*Tasks should have members that include: state, period,
		a measurement of elapsed time, and a function pointer.*/
	signed char state; //Task's current state
	unsigned long int period; //Task period
	unsigned long int elapsedTime; //Time elapsed since last task tick
	int (*TickFct)(int); //Task tick function
} task;

//--------End Task scheduler data structure-----------------------------------

//--------Shared Variables----------------------------------------------------
unsigned char count, i, display;
const unsigned char NUM_SPACES = 5;
enum sensor_states{sensor_start, input} sensor_state;
enum arm_states{arm_start, down, up} arm_state;
enum display_states{display_start, same, update, full} display_state;

void sensorTick()
{
	switch(sensor_state)
	{
		case sensor_start:
		sensor_state = input;
		break;
		case input:
		sensor_state = input;
		break;
	}
	switch(sensor_state)
	{
		case sensor_start:
			break;
		case input:
			count = 0x00;
			for(i = 0; i < 5; i++)
			{
				if(i == 0)
				{
					if((PINA & 0x01) == 0x00)
					{
						count = count + 1;
					}
				}
				else if(((PINA >> i) & 0x01) == 0x00)
				{
					count = count + 1;
				}
			}
			count = count;
			break;
		default:
			break;
	}
}

void armTick()
{
	// Transitions
	switch(arm_state)
	{
		case arm_start:
			arm_state = down;
			break;
		case down:
			if(D4 && (count < NUM_SPACES))
			{
				arm_state = up;
			}
			else if(D6 && !D4)
			{
				arm_state = down;
			}
			break;
		case up:
			if(D4 && !D6)
			{
				arm_state = up;
			}
			else if(D6 && !D4)
			{
				arm_state = down;
			}
			break;
	}
	
	// Actions
	switch(arm_state)
	{
		case arm_start:
			break;
		case up:
			OCR1A = 65;	// Set servo shaft at -90° position
			_delay_ms(1000);
			break;
		case down:
			OCR1A = 175;	// Set servo shaft at 0° position
			_delay_ms(1000);
			break;
		default:
			break;
	}
}

unsigned char display = 0x00;

void displayTick()
{
	// Transitions
	switch(display_state)
	{
		case display_start:
			display_state = same;
			break;
		case same:
			if(display == count)
			{
				display_state = same;
			}
			if(display != count)
			{
				display_state = update;
			}
			break;
		case update:
			if(count != NUM_SPACES)
			{
				display_state = same;
				switch(count)
				{
					case 0:
						nokia_lcd_clear();
						nokia_lcd_set_cursor(0, 10);
						nokia_lcd_write_string("EMPTY", 3);
						nokia_lcd_render();
						break;
					case 1:
						nokia_lcd_clear();
						nokia_lcd_set_cursor(0, 10);
						nokia_lcd_write_string("4", 3);
						nokia_lcd_render();
						break;
					case 2:
						nokia_lcd_clear();
						nokia_lcd_set_cursor(0, 10);
						nokia_lcd_write_string("3", 3);
						nokia_lcd_render();
						break;
					case 3:
						nokia_lcd_clear();
						nokia_lcd_set_cursor(0, 10);
						nokia_lcd_write_string("2", 3);
						nokia_lcd_render();
						break;
					case 4:
						nokia_lcd_clear();
						nokia_lcd_set_cursor(0, 10);
						nokia_lcd_write_string("1", 3);
						nokia_lcd_render();
						break;
				}
			}
			else
			{
					display_state = full;
					nokia_lcd_clear();
					nokia_lcd_set_cursor(0, 10);
					nokia_lcd_write_string("FULL", 3);
					nokia_lcd_render();
					break;
			}
			break;
		case full:
			if(count == NUM_SPACES)
			{
				display_state = full;
			}
			else
			{
				display_state = same;
				switch(count)
				{
					case 0:
						nokia_lcd_clear();
						nokia_lcd_set_cursor(0, 10);
						nokia_lcd_write_string("EMPTY", 3);
						nokia_lcd_render();
						break;
					case 1:
						nokia_lcd_clear();
						nokia_lcd_set_cursor(0, 10);
						nokia_lcd_write_string("4", 3);
						nokia_lcd_render();
						break;
					case 2:
						nokia_lcd_clear();
						nokia_lcd_set_cursor(0, 10);
						nokia_lcd_write_string("3", 3);
						nokia_lcd_render();
						break;
					case 3:
						nokia_lcd_clear();
						nokia_lcd_set_cursor(0, 10);
						nokia_lcd_write_string("2", 3);
						nokia_lcd_render();
						break;
					case 4:
						nokia_lcd_clear();
						nokia_lcd_set_cursor(0, 10);
						nokia_lcd_write_string("1", 3);
						nokia_lcd_render();
						break;
				}
				break;
		}
	}
	// Actions
	switch(display_state)
	{
		case display_start:
			break;
		case same:
			display = NUM_SPACES - count;
			break;
		case update:
			display = NUM_SPACES - count;
			break;
		case full:
			display = NUM_SPACES - count;
			break;
	}
}



// --------END User defined FSMs-----------------------------------------------

// Implement scheduler code from PES.
int main()
{
	nokia_lcd_init();

	// Set Data Direction Registers
	// Buttons PORTA[0-7], set AVR PORTA to pull down logic
	PORTA = 0x00;	// Parking sensor inputs A0 - A7
	PINA = 0x00;
	//DDRC = 0xFF; // Set port C to output
	//PORTC = 0x00; // Parking sensors

	PORTD = 0xFF;	// Servo motor inputs D0 and D1
	DDRD = 0x00;	// Servo motor output D5
	DDRD |= (1 << PD5);	/* Make OC1A pin as output */
	TCNT1 = 0;		/* Set timer1 count zero */
	ICR1 = 2499;		/* Set TOP count for timer1 in ICR1 register */

	/* Set Fast PWM, TOP in ICR1, Clear OC1A on compare match, clk/64 */
	TCCR1A = (1<<WGM11)|(1<<COM1A1);
	TCCR1B = (1<<WGM12)|(1<<WGM13)|(1<<CS10)|(1<<CS11);



	// Period for the tasks
	unsigned long int sensor_calc = 1000;
	unsigned long int arm_calc = 1000;
	unsigned long int display_calc = 1000;

	//Calculating GCD
	unsigned long int tmpGCD = 1;
	tmpGCD = findGCD(tmpGCD, sensor_calc);
	tmpGCD = findGCD(tmpGCD, arm_calc);
	tmpGCD = findGCD(tmpGCD, display_calc);

	//Greatest common divisor for all tasks or smallest time unit for tasks.
	unsigned long int GCD = tmpGCD;

	//Recalculate GCD periods for scheduler
	unsigned long int sensor_period = sensor_calc / GCD;
	unsigned long int arm_period = arm_calc / GCD;
	unsigned long int display_period = display_calc / GCD;

	//Declare an array of tasks 
	static task task1, task2, task3; //, task3, task4;
	task *tasks[] = {&task1, &task2, &task3};
	const unsigned short numTasks = sizeof(tasks)/sizeof(task*);

	task1.state = -1;//Task initial state.
	task1.period = sensor_period; //Task Period.
	task1.elapsedTime = sensor_period; //Task current elapsed time.
	task1.TickFct = &sensorTick;//Function pointer for the tick.

	task2.state = -1;//Task initial state.
	task2.period = arm_period; //Task Period.
	task2.elapsedTime = arm_period; //Task current elapsed time.
	task2.TickFct = &armTick;//Function pointer for the tick.

	task3.state = -1;//Task initial state.
	task3.period = arm_period; //Task Period.
	task3.elapsedTime = arm_period; //Task current elapsed time.
	task3.TickFct = &displayTick;//Function pointer for the tick.

	// Set the timer and turn it on
	TimerSet(GCD);
	TimerOn();
	PWM_on();

	unsigned short i; // Scheduler for-loop iterator
	while(1) 
	{
		// Scheduler code
		for(i = 0; i < numTasks; i++) 
		{
			// Task is ready to tick
			if(tasks[i]->elapsedTime >= tasks[i]->period) 
			{
				// Setting next state for task
				tasks[i]->state = tasks[i]->TickFct(tasks[i]->state);
				// Reset the elapsed time for next tick.
				tasks[i]->elapsedTime = 0;
			}
			tasks[i]->elapsedTime += GCD;
		}
		while(!TimerFlag);
		TimerFlag = 0;
	}

// Error: Program should not exit!
return 0;
}






